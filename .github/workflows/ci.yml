# .github/workflows/ci.yml
name: FastAPI CI/CD Pipeline

# Controls when the workflow will run
on:
  push:
    branches: [ "main", "develop" ] # Runs on pushes to main or develop
  pull_request:
    branches: [ "main", "develop" ] # Runs on pull requests targeting main or develop

jobs:
  build-and-test:
    name: Build, Lint, and Test
    runs-on: ubuntu-latest # Specifies the type of runner

    strategy:
      matrix:
        python-version: ["3.10", "3.11"] # Test against multiple Python versions

    steps:
      # Step 1: Check out the repository code
      - name: Checkout repository
        uses: actions/checkout@v4

      # Step 2: Set up Python environment
      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
          cache: 'pip' # Cache pip dependencies

      # Step 3: Install dependencies
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          # If you have a separate dev requirements for linters/pytest:
          # pip install -r requirements-dev.txt

      # Step 4: Lint with Flake8 (Optional)
      # Ensure Flake8 is in your requirements.txt or installed separately
      - name: Lint with Flake8
        run: |
          # pip install flake8 # Uncomment if not in requirements.txt
          # Stop the build if there are Python syntax errors or undefined names
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
          # Exit-zero treats all errors as warnings. For CI, you might want to fail on errors.
          # To fail on errors, remove --exit-zero or use a stricter configuration.
          flake8 . --count --max-complexity=10 --max-line-length=119 --statistics
        # To make the build fail if Flake8 finds issues, ensure it exits with a non-zero code for errors.

      # Step 5: Format with Black (Optional Check)
      # Ensure Black is in your requirements.txt or installed separately
      - name: Check formatting with Black
        run: |
          # pip install black # Uncomment if not in requirements.txt
          black --check .
        # This step will fail if Black finds files that need reformatting.

      # Step 6: Test with Pytest
      # Ensure pytest and pytest-cov are in your requirements.txt
      - name: Test with Pytest
        run: |
          # pip install pytest pytest-cov # Uncomment if not in requirements.txt
          # Assumes your tests are in a 'test' or 'tests' directory and app code in 'app'
          pytest test/ --cov=app --cov-report=xml --cov-report=term-missing
          # Adjust 'test/' to your actual test directory name if different (e.g., 'tests/')

      # Step 7: Build Docker image (verifies Dockerfile)
      - name: Build Docker image
        if: success() # Only run if previous steps were successful
        run: |
          docker build . --file Dockerfile --tag your-app-name:${{ github.sha }}
          # Replace 'your-app-name' with a suitable name for your application image

  # Optional Job: Push Docker image to GitHub Container Registry (GHCR)
  # This job runs only on pushes to the 'main' branch after build-and-test succeeds.
  push-to-ghcr:
    name: Push Docker Image to GHCR
    needs: build-and-test # Depends on the build-and-test job succeeding
    runs-on: ubuntu-latest
    # Only run on a push to the main branch
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    permissions:
      contents: read
      packages: write # Required to push to GHCR

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        # Allows building multi-platform images, though not strictly necessary for a single platform push.
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }} # Or your GitHub username if deploying to personal GHCR
          password: ${{ secrets.GITHUB_TOKEN }}   # GITHUB_TOKEN is automatically available

      - name: Build and push Docker image to GHCR
        uses: docker/build-push-action@v5
        with:
          context: . # Build context is the root of the repository
          file: ./Dockerfile # Path to your Dockerfile
          push: true # Actually push the image
          tags: |
            ghcr.io/${{ github.repository_owner }}/your-app-name:latest
            ghcr.io/${{ github.repository_owner }}/your-app-name:${{ github.sha }}
            # Replace 'your-app-name' with your actual image name.
            # It's common to use lowercase and hyphens for image names.
            # Example: ghcr.io/your-username/my-fastapi-app:latest

  # Placeholder for Deployment Job (e.g., to Google Cloud Run, AWS, etc.)
  # deploy-to-production:
  #   name: Deploy to Production
  #   needs: push-to-ghcr # Depends on the image being successfully pushed
  #   runs-on: ubuntu-latest
  #   if: github.event_name == 'push' && github.ref == 'refs/heads/main'
  #
  #   steps:
  #     - name: Deploy to (e.g., Google Cloud Run)
  #       run: |
  #         echo "Deploying image ghcr.io/${{ github.repository_owner }}/your-app-name:${{ github.sha }} to production..."
  #         # Add your actual deployment commands here
  #         # This would involve authenticating to your cloud provider and using their CLI/SDK
  #         # For example, gcloud run deploy ...
